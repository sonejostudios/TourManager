import sys
import datetime
import os.path

import pandas as pd
from ics import Calendar, Event


# --------------------------------------------- HTML FILES ---------------------------------------------

#export all shows into ONE html file:
def export_shows_to_html(df_shows, df_venues, workdir_path, ui):
    print("Export future shows:")
    df_upcoming_shows = df_shows.loc[(df_shows['Status'] == 0) | (df_shows['Status'] == 2)] # get upcoming and work in progress shows
    print(df_upcoming_shows)

    # create title
    output = "UPCOMING and WORK IN PROGRESS shows (" + f"{datetime.datetime.now():%Y-%m-%d}" + ")<br/>"

    # iterate through shows_df and concat venue_df, then append text to output
    for i, row in df_upcoming_shows.iterrows():
        if row["VenueID"] in df_venues.index:
            venue = df_venues.loc[row["VenueID"]]
            df_out = pd.concat([row, venue])
            df_out = df_out.drop(["VenueID","EmailHide", "Tags", "Status", "ShowID",
                                        "VenueGeoCoordinates", "VenueIsEvent", "VenueStartDate", "VenueEndDate",
                                        "VenueGenres", "VenueCapacity", "VenueRating", "VenueIsDiscontinued",
                                        "VenueEmailHide", "VenueTags", "VenueID"], axis=0)

            output += "<br/>" + df_out.to_markdown(index=True, tablefmt="html") + "<br/>"  # also possible: .to_string(index=True)
            #output += "<br/>" + df_out.to_string(index=True) + "<br/>"
            #output += "<br/>" + df_out.to_frame().to_html() + "<br/>"


    # write output to text file
    export_path = os.path.join(workdir_path, "FutureShows.html")
    with open(export_path, 'w', encoding='utf-8') as file:
        file.write(output)

    ui.statusbar.showMessage("Future Shows exported to HTML-file!", 3000)




# --------------------------------------------- CALENDARS ---------------------------------------------


def export_all_calendars(df_shows, df_venues, workdir_path, ui, show_status_list):
    export_show_calendar(df_shows, workdir_path, show_status_list)
    export_event_calendar(df_venues, workdir_path)
    export_event_forcast_calendar(df_venues, workdir_path)

    ui.statusbar.showMessage("Show Calendar and Event Calendar exported to ICS-files!", 3000)




def export_show_calendar(df_shows, workdir_path, show_status_list): # SHOWS
    print("export show calendar")
    # to subscribe in thunderbird (Add Network Calendar) with url:
    # file:///path/to/your/workdir/TourManagerShows.ics

    c = Calendar()
    for i, row in df_shows.iterrows():
        if row["Status"] != 4: # export all shows except CANCELLED
            e = Event()
            e.summary = row["Artist"] + ": " + row["City"] + " - " + row["Venue"] + " (" + row["Country"] + ")"

            status_text = show_status_list[row["Status"]]
            e.description = ("Show Status: " + status_text +
                             "\nArrival: " + row["ArrivalTime"] +
                             "\nTechnical Check: " + row["TechCheckTime"] +
                             "\nDoors Opening: " + row["OpeningTime"] +
                             "\nShow Time: " + row["ShowTime"] +
                             "\n\n(Generated by TourManager - do not modify)")

            e.begin = datetime.datetime.fromisoformat(row["Date"]).date()
            e.make_all_day()
            c.events.append(e)

    # export to file
    export_calendar_to_file(c, workdir_path, "TourManagerShows.ics")





def export_event_calendar(df_venues, workdir_path): # EVENTS
    print("export event calendar")
    c = Calendar()
    for i, row in df_venues.iterrows():
        if row["VenueStartDate"] != "":
            #print(row["VenueName"], row["VenueStartDate"], row["VenueEndDate"])
            e = Event()
            e.summary = row["VenueName"] #+ " (" + row["VenueCity"] + " - " + row["VenueCountry"] + ")"

            e.description = ("Name: " + row["VenueName"] +
                             "\nCity: " + row["VenueCity"] +
                             "\nCountry: " + row["VenueCountry"] +
                             "\n\n(Generated by TourManager - do not modify)")

            e.begin = datetime.datetime.fromisoformat(row["VenueStartDate"])
            if row["VenueEndDate"] != row["VenueStartDate"]:
                e.end = datetime.datetime.fromisoformat(row["VenueEndDate"]) + datetime.timedelta(hours=12) # + timedelta needed otherwise end day is one day before (ics 0.8.0dev)
            e.make_all_day()
            c.events.append(e)

    # export to file
    export_calendar_to_file(c, workdir_path, "TourManagerEvents.ics")




def export_event_forcast_calendar(df_venues, workdir_path): # EVENTS FORECAST
    print("export event forecast calendar")
    c = Calendar()
    for i, row in df_venues.iterrows():
        if row["VenueStartDate"] != "":
            e = Event()
            year = row["VenueStartDate"].split("-")[0]
            e.summary = year + ": " + row["VenueName"]

            e.description = ("THIS IS THE FORECAST FROM THE " + year + " EVENT.\nPlease update the event's dates."
                             "\n\nName: " + row["VenueName"] +
                             "\nCity: " + row["VenueCity"] +
                             "\nCountry: " + row["VenueCountry"] +
                             "\n\n(Generated by TourManager - do not modify)")

            e.begin = datetime.datetime.fromisoformat(row["VenueStartDate"]) + datetime.timedelta(days=365) # add one year
            if row["VenueEndDate"] != row["VenueStartDate"]:
                e.end = datetime.datetime.fromisoformat(row["VenueEndDate"]) + datetime.timedelta(days=365, hours=12) # + timedelta needed otherwise end day is one day before (ics 0.8.0dev)
            e.make_all_day()
            c.events.append(e)

    # export to file
    export_calendar_to_file(c, workdir_path, "TourManagerEventsForecast.ics")



def export_calendar_to_file(calendar, workdir_path, filename):
    export_path = os.path.join(workdir_path, filename)
    with open(export_path, "w", newline="", encoding="utf-8") as my_file:
        my_file.write(calendar.serialize())